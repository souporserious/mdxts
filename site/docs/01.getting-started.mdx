export const metadata = {
  title: 'Getting Started',
}

MDXTS is a collection of components and utilities for rendering [MDX](https://mdxjs.com/) content, type documentation, and code examples in React.

<Note>
  In some cases this library uses [React Server
  Components](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components)
  which are currently limited to only a few frameworks. First-class support is
  offered for Next.js through a [plugin](/packages/next). Please open an issue
  or PR if you are interested in supporting other frameworks.
</Note>

## Automated Setup

The CLI tool is the quickest way to get started using MDXTS. Run the following command in the root of your Next.js project to walk through configuring the plugin and rendering a source:

```sh
npm create mdxts
```

## Manual Setup

Alternatively, follow the manual setup guide below to learn how to configure the Next.js plugin and define and render a source.

### Install

In your Next.js project, run the following command to install the `mdxts` package:

<PackageInstall
  packages={['mdxts']}
  style={{
    container: {
      width: 'calc(100% + 2rem)',
      margin: '0 -1rem',
    },
    tabs: {
      fontSize: '0.875rem',
    },
  }}
/>

### Configuring the Next.js Plugin

The Next.js plugin sets up everything needed for authoring MDX files and collecting type documentation. This includes default remark plugins, MDX components, and a loader for gathering collections of modules.

```js filename="next.config.mjs"
import { createMdxtsPlugin } from 'mdxts/next'

const withMdxts = createMdxtsPlugin({
  theme: 'nord',
  gitSource: 'https://github.com/souporserious/mdxts',
})

export default withMdxts({
  // Next.js config options here...
})
```

The `theme` option is used for syntax highlighting code blocks and is powered by [Shiki](https://shiki.matsu.io/). The `theme` value should correspond to either a built-in theme or a source path to a custom theme that adheres to the [VS Code theme specification](https://code.visualstudio.com/api/extension-guides/color-theme).

### Defining a Data Source (Optional)

Use the `createSource` utility to generate metadata and helpers for MDX and TypeScript source files that can be used to build routes for content and documentation:

```ts filename="data.ts"
import { createSource } from 'mdxts'

export const allDocs = createSource('docs/**/*.mdx')

allDocs.paths() // => [['docs', 'getting-started'], ['docs, 'authoring']]
```

Visit the [routing](./02.routing.mdx) section for more information on how to use `paths` to generate routes.

### Rendering Content

Use the `get` method from the `allDocs` source we created above to retrieve the metadata for a specific document and render its content:

```tsx filename="app/blog/[slug]/page.tsx"
import { notFound } from 'next/navigation'
import { allDocs } from '../../../data'

type Props = { params: { slug: string } }

export default async function Page({ params }: Props) {
  const doc = await allDocs.get(params.slug)

  if (doc === undefined) {
    return notFound()
  }

  const { Content } = doc

  return <Content />
}
```

### Rendering Type Documentation

If the targeted source files are TypeScript files, the exported types will also be analyzed and included along with other metadata like associated MDX content and examples:

```tsx filename="app/components/[slug]/page.tsx"
import { createSource } from 'mdxts'
import { notFound } from 'next/navigation'

type Props = { params: { slug: string } }

const allComponents = createSource('components/**/*.tsx')

export default async function Page({ params }: Props) {
  const component = await allComponents.get(params.slug)

  if (component === undefined) {
    return notFound()
  }

  const { Content, exportedTypes } = component

  return (
    <>
      {Content ? <Content /> : null}
      <ul>
        {exportedTypes.map((type) => (
          <li key={type.name}>
            <h4>{type.name}</h4>
            <p>{type.description}</p>
            {type.types.map((type) =>
              type.properties ? (
                <ul>
                  {type.properties.map((property) => (
                    <li key={property.name}>
                      <h5>{property.name}</h5>
                      <p>{property.description}</p>
                    </li>
                  ))}
                </ul>
              ) : (
                type.text
              )
            )}
          </li>
        ))}
      </ul>
    </>
  )
}
```

<Note>
  When targeting JavaScript or TypeScript files, heuristics are used to infer
  public metadata. First, package exports will be used if present, otherwise,
  the presence of an `index` file will be used to infer public exports. If these
  both fail, the entire directory will be analyzed.
</Note>

### Type Checking

All code blocks will automatically be type-checked using the TypeScript compiler to ensure code works as expected. Notice the following will throw a type error because `b` is not defined:

```tsx
const a = 1
a + b
```

We can pass `allowErrors` to disable type checking in this case:

````mdx
```tsx allowErrors
const a = 1
a + b
```
````

```tsx allowErrors
const a = 1
a + b
```

This is useful for showing incomplete or incorrect code examples in documentation for educational purposes. Read more about [type checking](./03.type-checking.mdx) to learn how the TypeScript compiler is used for providing type information for code blocks and validating front matter fields.

### Examples

To associate examples with a source file, create a sibling file with the same name and a `.examples.tsx` extension:

```tsx filename="components/Button.tsx"
export const Button = ({ children }) => <button>{children}</button>
```

```tsx filename="components/Button.examples.tsx"
import { Button } from './Button'

export const Basic = () => <Button>Click Me</Button>
```

When collecting information about a TypeScript source file (`Button.tsx` in this case), the examples will be included in the metadata. Read more about [examples](./04.examples/01.authoring.mdx) to learn how to generate interactive documentation and render them to a route.

## Next Steps

Check out the [routing](./02.routing.mdx) section to learn how to generate routes for your content and documentation.
