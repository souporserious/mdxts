import { Project } from 'ts-morph'
import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'node:fs'
import { extname, resolve, join, dirname, relative } from 'node:path'
import globParent from 'glob-parent'
import { glob } from 'fast-glob'

import { getCollectionConfigurations } from './get-collection-configurations'
import { getProject } from '../project/get-project'
import { resolveTsConfigPath } from './resolve-ts-config-path'

export const PACKAGE_NAME = 'renoun/core'
export const PACKAGE_DIRECTORY = '.renoun'
export const FILENAME = 'collections.ts'
export const FILE_PATH = `${PACKAGE_DIRECTORY}/${FILENAME}`

type GetImport<Exports extends unknown = unknown> = (
  slug: string
) => Promise<Exports>

let importMap = new Map<string, GetImport>()

/**
 * Sets the import maps for a collection's file patterns.
 *
 * @internal
 * @param entries - An array of tuples where the first element is a file pattern and the second element is a function that returns a promise resolving to the import.
 */
export function setImportMap(...entries: (string | GetImport)[]) {
  const parsedEntries: [string, GetImport][] = []

  for (let index = 0; index < entries.length; index += 2) {
    parsedEntries.push([
      entries[index] as string,
      entries[index + 1] as GetImport,
    ])
  }

  importMap = new Map(parsedEntries)
}

/**
 * Retreives the import map for a collection's file pattern.
 *
 * @internal
 * @param slug - The file pattern to retrieve the import map for.
 * @returns The import map for the file pattern.
 */
export function getImportMap<AllExports>(slug: string) {
  return importMap.get(slug) as GetImport<AllExports>
}

/**
 * Generates import maps for each file pattern at the root of the project.
 *
 * @param patterns - An array of file patterns to match.
 * @param sourceFilesMap - A map of file patterns to their respective source files.
 */
async function writeImportMap(
  collectionConfigurations: ReturnType<typeof getCollectionConfigurations>
) {
  const configs = Array.from(collectionConfigurations)
  const importMapEntries: string[] = []

  await Promise.all(
    configs.map(async ([filePattern, options]) => {
      const project = await getProject({
        tsConfigFilePath: options?.tsConfigFilePath || 'tsconfig.json',
      })
      const compilerOptions = project.getCompilerOptions()
      const tsConfigFilePath = compilerOptions.configFilePath
      const tsConfigDirectory = tsConfigFilePath
        ? dirname(String(tsConfigFilePath))
        : project.getDirectoryOrThrow('.').getPath()
      const absoluteGlobPattern =
        compilerOptions.baseUrl && compilerOptions.paths
          ? resolveTsConfigPath(
              tsConfigDirectory,
              compilerOptions.baseUrl,
              compilerOptions.paths,
              filePattern
            )
          : resolve(tsConfigDirectory, filePattern)
      const filePaths = await glob(absoluteGlobPattern)

      if (process.env.NODE_ENV === 'production' && filePaths.length === 0) {
        throw new Error(
          `[renoun] No source files found for collection while attempting to generate import map for file pattern: ${filePattern}
  
  You can fix this error by ensuring the following:
    
    - The file pattern is formatted correctly and targeting files that exist.
    - If using a relative path, ensure the "tsConfigFilePath" option is targeting the correct workspace.
    - If you continue to see this error, please file an issue: https://github.com/souporserious/renoun/issues\n`
        )
      }

      const relativeGlobPattern = relative(
        join(process.cwd(), PACKAGE_DIRECTORY),
        absoluteGlobPattern
      )
      const baseGlobPattern = globParent(relativeGlobPattern)
      const allExtensions = Array.from(new Set(filePaths.map(extname)))

      allExtensions.forEach((extension) => {
        const trimmedExtension = extension.slice(1)

        importMapEntries.push(
          `\`${trimmedExtension}:${filePattern}\``,
          `(slug) => import(\`${baseGlobPattern}/\${slug}${extension}\`)`
        )
      })
    })
  )

  const currentImportMap = existsSync(FILE_PATH)
    ? readFileSync(FILE_PATH, 'utf-8')
    : null
  const nextImportMap = [
    `/*\n * This file is automatically generated and managed by the \`renoun\` package.\n * It is aliased in the tsconfig.json file and can be added to .gitignore or committed. \n */`,
    `import { createCollection } from '${PACKAGE_NAME}'\n`,
    `createCollection.setImportMap(\n${importMapEntries
      .flatMap((entry) => `  ${entry}`)
      .join(',\n')}\n)\n`,
    `export * from '${PACKAGE_NAME}'\n`,
  ].join('\n')

  if (currentImportMap === nextImportMap) {
    return
  }

  writeFileSync(FILE_PATH, nextImportMap)
}

/** Updates the tsconfig.json file to include the `renoun` package alias in the `paths` field. */
function codemodTsConfigPaths(project: Project) {
  const tsconfigFilePath = project.getCompilerOptions().configFilePath

  if (typeof tsconfigFilePath === 'string') {
    const tsconfigContents = readFileSync(tsconfigFilePath, 'utf-8') || '{}'
    const tsconfigJson = JSON.parse(tsconfigContents)

    if (!tsconfigJson.compilerOptions) {
      tsconfigJson.compilerOptions = {}
    }

    if (!tsconfigJson.compilerOptions.paths) {
      tsconfigJson.compilerOptions.paths = {}
    }

    const renounPath = tsconfigJson.compilerOptions.paths['renoun/*']

    if (renounPath === undefined || renounPath[0].endsWith('js')) {
      tsconfigJson.compilerOptions.paths['renoun/*'] = [
        join(PACKAGE_DIRECTORY, '*.ts'),
      ]

      writeFileSync(tsconfigFilePath, JSON.stringify(tsconfigJson, null, 2))
    }
  }
}

let project: Project

/** Initializes an import map at the root of the project based on all `createCollection` configurations. */
export async function generateCollectionImportMap(filename?: string) {
  /* Use a default project to find all collection configurations and generate the collection import map. */
  if (!project) {
    project = new Project({ tsConfigFilePath: 'tsconfig.json' })
  }

  /* Refresh source file if the contents changed. */
  if (filename) {
    const sourceFile = project.getSourceFile(filename)

    if (sourceFile) {
      await sourceFile.refreshFromFileSystem()
    }
  }

  /* Prime the file so it gets picked up by the bundler. */
  if (!existsSync(PACKAGE_DIRECTORY)) {
    mkdirSync(PACKAGE_DIRECTORY)
  }

  writeFileSync(FILE_PATH, `export * from '${PACKAGE_NAME}';\n`)

  /* Update the tsconfig.json file to include the `renoun` package alias in the `paths` field. */
  codemodTsConfigPaths(project)

  /* Find all `createCollection` call sites and extract the file patterns and options. */
  const collectionConfigurations = getCollectionConfigurations(project)

  if (collectionConfigurations.size > 0) {
    if (!existsSync(PACKAGE_DIRECTORY)) {
      mkdirSync(PACKAGE_DIRECTORY)
    }

    await writeImportMap(collectionConfigurations)
  }
}
